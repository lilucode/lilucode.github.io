<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="视图响应-watch对象、数组"><meta name="keywords" content="视图响应-watch对象、数组"><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><title>视图响应-watch对象、数组 | LILU</title><link rel="icon" href="/tou.jpeg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header id="page-header"><nav id="navbar"><span class="nav-left"><a id="site-name" href="/">LILU</a></span><i class="fa fa-bars toggle-menu nav-right" aria-hidden="true"></i><span class="title">视图响应-watch对象、数组</span><span class="nav-right menus"><a class="site-page" href="/about">About Me</a></span></nav></header><article id="content-outer"><section id="content-inner"><article class="article-entry" id="post"><p>数据改变（vue视图上的数据能渲染成功）时会触发对应的监听器watch。<br />vue提供了<code>watch</code>方法，用于监听实例内<code>data</code>数据的变化。<br /></p>
<h1 id="一、普通类型字符串等监听"><a href="#一、普通类型字符串等监听" class="headerlink" title="一、普通类型字符串等监听"></a>一、普通类型字符串等监听</h1><p>直接监听</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;about&quot;&gt;</span><br><span class="line">  &lt;!-- v-bind只视图绑定数据，视图修改无法触发监听watch方法，只能数据修改触发watch并渲染视图 --&gt;</span><br><span class="line">  &lt;!-- v-model实现双向数据绑定，视图修改触发监听watch方法 --&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; :value=&quot;name&quot; /&gt;</span><br><span class="line">    &lt;button @click=&quot;change1&quot;&gt;更新视图&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;age&quot; /&gt;</span><br><span class="line">    &lt;button @click=&quot;change2&quot;&gt;更新视图&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name: &quot;lilu&quot;,</span><br><span class="line">        age: 20,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      change1() &#123;</span><br><span class="line">        this.name = this.name + &quot;1&quot;;</span><br><span class="line">      &#125;,</span><br><span class="line">      change2() &#123;</span><br><span class="line">        this.age = this.age + &quot;1&quot;;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      // 修改字符串、数组直接渲染视图，监听到改变</span><br><span class="line">      name(newVal, oldVal) &#123;</span><br><span class="line">        console.log(&quot;name:newVal--&quot; + newVal + &quot;,oldVal--&quot; + oldVal);</span><br><span class="line">      &#125;,</span><br><span class="line">      age: function (newVal, oldVal) &#123;</span><br><span class="line">        console.log(&quot;age:newVal--&quot; + newVal + &quot;,oldVal--&quot; + oldVal);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="二、对于对象"><a href="#二、对于对象" class="headerlink" title="二、对于对象"></a>二、对于对象</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;about&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; :value=&quot;JSON.stringify(friend)&quot; style=&quot;width: 300px&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; :value=&quot;friend.friendName&quot; /&gt;</span><br><span class="line">  &lt;button @click=&quot;changeFriendName&quot;&gt;更新视图&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        obj: &quot;oo&quot;,</span><br><span class="line">        friend: &#123;</span><br><span class="line">          friendName: &quot;yin&quot;,</span><br><span class="line">          age: 24,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="监听对象本身"><a href="#监听对象本身" class="headerlink" title="监听对象本身"></a>监听对象本身</h2><p>直接监听对象是监听对象的指向，不能监听到某个对象里面属性的变化。<br />如果需要监听的数据是对象内的某一属性值的变化，直接<code>watch</code>对象friend是检测不到变化的，这是因为friend这个对象的指向并没有发生改变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">      friend(newVal, oldVal) &#123;</span><br><span class="line">        console.log(&quot;friend:newVal--&quot; + newVal + &quot;,oldVal--&quot; + oldVal);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="触发监听"><a href="#触发监听" class="headerlink" title="触发监听"></a>触发监听</h3><p>直接改变对象会触发监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.friend = &#123;</span><br><span class="line">  <span class="attr">friendName</span>: <span class="string">&quot;yin&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lu&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="监听对象内属性变化"><a href="#监听对象内属性变化" class="headerlink" title="监听对象内属性变化"></a>监听对象内属性变化</h2><h3 id="方法一：深度检测"><a href="#方法一：深度检测" class="headerlink" title="方法一：深度检测"></a>方法一：深度检测</h3><p><code>deep</code>设为了<code>true</code>，修改了这个friend中的任何一个属性，都会执行handler这个方法。不过这样会造成更多的性能开销，尤其是对象里面属性过多，结构嵌套过深的时候。而且有时候我们就只想关心这个对象中的某个特定属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">      friend: &#123;</span><br><span class="line">        handler(newVal, oldVal) &#123;</span><br><span class="line">          console.log(&quot;deep friend:newVal--&quot; + newVal + &quot;,oldVal--&quot; + oldVal);</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: true,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>扩展：handler声明函数或函数表达式都可以，但是不能箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch : &#123;</span><br><span class="line">	<span class="attr">newA</span> : &#123;</span><br><span class="line">		<span class="attr">handler</span> : <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(newVal,oldVal)</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">immediate</span> : <span class="literal">true</span>, <span class="comment">//初始化页面后立即监听</span></span><br><span class="line">    <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">	&#125; </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="immediate属性"><a href="#immediate属性" class="headerlink" title="immediate属性"></a>immediate属性</h4><p>没有的时候上面的例子是值变化时候，watch才执行，我们想让值最初时候watch就执行就用到了<code>handler</code>和<code>immediate</code>属性，immediate : true代表在wacth里声明了newA这个方法之后立即先去执行handler方法，如果设置了false，那么效果和没有一样</p>
<h3 id="方法二：字符串来表示属性的调用"><a href="#方法二：字符串来表示属性的调用" class="headerlink" title="方法二：字符串来表示属性的调用"></a>方法二：字符串来表示属性的调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">      &quot;friend.friendName&quot;(newVal, oldVal) &#123;</span><br><span class="line">        console.log(&quot;string friend:newVal--&quot; + newVal + &quot;,oldVal--&quot; + oldVal);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：使用computed属性"><a href="#方法三：使用computed属性" class="headerlink" title="方法三：使用computed属性"></a>方法三：使用computed属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">      // 和computed计算属性名一样</span><br><span class="line">      friendName(newVal, oldVal) &#123;</span><br><span class="line">        console.log(&quot;computed friend:newVal--&quot; + newVal + &quot;,oldVal--&quot; + oldVal);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      friendName() &#123;</span><br><span class="line">        return this.friend.friendName;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="触发监听-1"><a href="#触发监听-1" class="headerlink" title="触发监听"></a>触发监听</h3><h4 id="1、修改现有对象某个属性对应的值"><a href="#1、修改现有对象某个属性对应的值" class="headerlink" title="1、修改现有对象某个属性对应的值"></a>1、修改现有对象某个属性对应的值</h4><p>把对象某个属性的值修改都触发，无论改成基本类型还是引用对象，而且引用对象内vue也能监听到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1:数据修改成功，视图修改成功=三种方式的属性监听都触发</span></span><br><span class="line"><span class="built_in">this</span>.friend.friendName = <span class="string">&quot;li&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2、属性的添加"><a href="#2、属性的添加" class="headerlink" title="2、属性的添加"></a>2、属性的添加</h4><p>对于已经创建的实例，Vue 不允许动态添加根级别(外层内层都监听不到)的响应式 property:  无法渲染<br /><strong>解决方案：</strong></p>
<ul>
<li><p>预先留出变量</p>
</li>
<li><p>使用this.$set / Vue.set()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.friend.sex = <span class="string">&quot;girl&quot;</span>;		<span class="comment">// 数据修改但无法渲染 = 监听不到</span></span><br><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.friend, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;boy&quot;</span>); <span class="comment">// 可以渲染，deep watch可以监听</span></span><br></pre></td></tr></table></figure>
<h4 id="3、属性的删除"><a href="#3、属性的删除" class="headerlink" title="3、属性的删除"></a>3、属性的删除</h4><p>Vue 无法检测 property 的移除<br /><strong>解决方案：</strong></p>
</li>
<li><p>Vue.delete()删除对象某个元素后，会立即触发页面渲染：Vue.delete(propertyName/index)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="built_in">this</span>.friend.age;	<span class="comment">//数据删除但无法渲染 = 监听不到</span></span><br><span class="line"><span class="built_in">this</span>.$delete(<span class="built_in">this</span>.friend, <span class="string">&quot;age&quot;</span>); <span class="comment">// 可以渲染，deep watch可以监听</span></span><br></pre></td></tr></table></figure>
<h1 id="三、对于数组"><a href="#三、对于数组" class="headerlink" title="三、对于数组"></a>三、对于数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;about&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; :value=&quot;colors&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; :value=&quot;colors[0]&quot; /&gt;</span><br><span class="line">  &lt;button @click=&quot;changeColors&quot;&gt;更新视图&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        colors: [&quot;red&quot;, &quot;orange&quot;, &quot;green&quot;]</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="监听数组"><a href="#监听数组" class="headerlink" title="监听数组"></a>监听数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">      colors(newVal, oldVal) &#123;</span><br><span class="line">        console.log(&quot;colors:newVal--&quot; + newVal + &quot;,oldVal--&quot; + oldVal);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="触发监听-2"><a href="#触发监听-2" class="headerlink" title="触发监听"></a>触发监听</h2><h3 id="1、直接赋值新数组"><a href="#1、直接赋值新数组" class="headerlink" title="1、直接赋值新数组"></a>1、直接赋值新数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子1:修改成功,数组、元素都渲染成功，触发上面对数组的监听</span></span><br><span class="line"><span class="built_in">this</span>.colors = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>];</span><br></pre></td></tr></table></figure>
<h3 id="2、利用索引直接设置一个数组项"><a href="#2、利用索引直接设置一个数组项" class="headerlink" title="2、利用索引直接设置一个数组项"></a>2、利用索引直接设置一个数组项</h3><p>例如：arr[indexOfItem] = newValue;<br />解决方案：</p>
</li>
<li><p>使用this.$set(arr, index, newVal)</p>
</li>
<li><p>使用splice(indexOfItem, 1, newValue):</p>
</li>
<li><p>使用临时变量直接赋值的方式，原理与直接赋值数组一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.colors[<span class="number">0</span>] = <span class="string">&quot;blue&quot;</span>;  <span class="comment">// 不是响应的，数据修改成功但渲染不成功 = 不触发监听</span></span><br><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.colors, <span class="number">0</span>, <span class="string">&quot;blue&quot;</span>)		<span class="comment">// 渲染成功 = 触发监听</span></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="built_in">this</span>.colors.splice(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;blue&quot;</span>);	<span class="comment">// 渲染成功 = 触发监听</span></span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="keyword">let</span> temp = [...this.colors];</span><br><span class="line">temp[<span class="number">0</span>] = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="built_in">this</span>.colors = temp;		<span class="comment">//渲染成功 = 触发监听</span></span><br></pre></td></tr></table></figure>
<h3 id="3、push数组"><a href="#3、push数组" class="headerlink" title="3、push数组"></a>3、push数组</h3><p>Vue可以监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.colors.push(<span class="string">&#x27;yellow&#x27;</span>)	<span class="comment">// 数据添加成功，视图渲染成功</span></span><br></pre></td></tr></table></figure>
<h3 id="4、修改数组的长度"><a href="#4、修改数组的长度" class="headerlink" title="4、修改数组的长度"></a>4、修改数组的长度</h3><p>例如：arr.length = newLength<br />长度大于原数组就将后续元素设置为 undefined, 长度小于原数组就将多余元素截掉。<br />解决方案：</p>
</li>
<li><p>this.$set(arr, index, newVal); </p>
</li>
<li><p>使用数组 splice 方法可以监听</p>
</li>
<li><p>使用临时变量直接赋值的方式，原理与直接赋值数组一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.colors.length = <span class="number">1</span>;	<span class="comment">// 数据修改成功，视图渲染不成功</span></span><br><span class="line">方法一：</span><br><span class="line"><span class="built_in">this</span>.colors.splice(<span class="number">1</span>)	<span class="comment">// 渲染成功 = 触发监听	1之后数组的元素都被删除，包括1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<div class="qr-code"></div><img class="qrcode-img" src="/img/weixin.jpeg"><div class="qrcode-desc"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/10/01/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"><i class="fa fa-chevron-left"></i><span>vue的生命周期</span></a></div><div class="next-post pull-right"><a href="/2019/06/16/this%E7%9A%84%E6%8C%87%E5%90%91/"><span>this的指向</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '618b746d5ea5d3e669cf',
  clientSecret: 'ebde2105d18532a7431b987c41e9904e905b5bfd',
  repo: 'lilucode.github.io',
  owner: 'lilucode',
  admin: 'lilucode',
  id: md5(window.location.pathname)
})
gitalk.render('gitalk-container')</script></article></section></article><footer id="footer-outer"><div id="footer-inner"><p class="footer-text">Copyright &copy; 2018 LI-LU</p></div></footer></body><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/main.js" defer></script></html>