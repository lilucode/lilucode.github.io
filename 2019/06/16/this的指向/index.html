<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="this的指向"><meta name="keywords" content="this的指向"><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><title>this的指向 | LILU</title><link rel="icon" href="/tou.jpeg"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header id="page-header"><nav id="navbar"><span class="nav-left"><a id="site-name" href="/">LILU</a></span><i class="fa fa-bars toggle-menu nav-right" aria-hidden="true"></i><span class="title">this的指向</span><span class="nav-right menus"><a class="site-page" href="/about">About Me</a></span></nav></header><article id="content-outer"><section id="content-inner"><article class="article-entry" id="post"><blockquote>
<p>学习：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34000916/article/details/88581297">https://blog.csdn.net/weixin_34000916/article/details/88581297</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lianjiuxiao/article/details/109839865">https://blog.csdn.net/lianjiuxiao/article/details/109839865</a></p>
</blockquote>
<h2 id="一、什么是this"><a href="#一、什么是this" class="headerlink" title="一、什么是this"></a>一、什么是this</h2><p>this是在运行时基于函数的执行环境绑定的，它的上下文取决于函数调用时的各种条件。<br />当一个函数被调用时，会创建一个活动记录(有时候也称执行上下文)。这个记录会包含函数在哪里被调用，函数的调用方法、出入的参数等信息。this就是记录其中一个属性，会在函数执行的过程中用到。<br /><strong><br /></strong><br /><strong>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁</strong>，<strong>实际上this的最终指向的是那个调用它的对象。</strong><br />#this的绑定与函数声明的位置没有声明的位置没有任何关系，只取决于函数的调用方式<br />#<strong><em>一般来说，谁最终调用了函数，那么它就是this的绑定对象。</em></strong><br />那在全局下调用函数，this的绑定对象也就是全局对象。</p>
<h2 id="二、this的指向哪几种"><a href="#二、this的指向哪几种" class="headerlink" title="二、this的指向哪几种"></a>二、this的指向哪几种</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p>默认绑定：全局环境中，this默认绑定到window。<br />隐式绑定：一般地，被直接对象所包含的函数调用时，也称为方法调用，this隐式绑定到该直接对象。<br />隐式丢失：隐式丢失是指被隐式绑定的函数丢失绑定对象，从而默认绑定到window。显式绑定：通过call()、apply()、bind()方法把对象绑定到this上，叫做显式绑定。<br />new绑定：如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。对于this绑定来说，称为new绑定。<br />- 在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 Window 对象）。<br />- 在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）。<br />- 当 new 一个新对象，this指向返回的那个对象。<br />- 箭头函数里的 this 在函数定义时指定，默认指向定义它时所处的对象。<br /><br><br />【1】构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。<br />【2】如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。<br />【3】如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象。<br /></p>
<h3 id="1、默认绑定到window"><a href="#1、默认绑定到window" class="headerlink" title="1、默认绑定到window"></a>1、默认绑定到window</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = <span class="string">&quot;追梦子&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.user); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// Window</span></span><br><span class="line">&#125;</span><br><span class="line">a();	<span class="comment">// undefined 返回值</span></span><br><span class="line"><span class="comment">// this最终指向的是调用它的对象，这里的函数a实际是被Window对象所点出来的，下面的代码就可以证明。</span></span><br><span class="line"><span class="built_in">window</span>.a();</span><br><span class="line"><span class="comment">// 和上面代码一样，其实alert也是window的一个属性，也是window点出来的。</span></span><br></pre></td></tr></table></figure>
<h3 id="2、对象内方法调用，绑定该对象"><a href="#2、对象内方法调用，绑定该对象" class="headerlink" title="2、对象内方法调用，绑定该对象"></a>2、对象内方法调用，绑定该对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">user</span>:<span class="string">&quot;追梦子&quot;</span>,</span><br><span class="line">    <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.user);  <span class="comment">//追梦子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.fn();</span><br><span class="line"><span class="comment">// 这里的this指向的是对象o，因为你调用这个fn是通过o.fn()执行的，那自然指向就是对象o</span></span><br><span class="line"><span class="built_in">window</span>.o.fn();</span><br><span class="line"><span class="comment">// 指向o，打印信息一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:&#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="number">12</span>,</span><br><span class="line">        <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a); <span class="comment">//12，指向父层b，只会是上一级，b如果没有a，这里打印undefined</span></span><br><span class="line">          	<span class="built_in">console</span>.log(<span class="built_in">this</span>);		<span class="comment">// 返回b</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn();</span><br></pre></td></tr></table></figure>

<p><br />情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。<br />情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。<br />情况3：如果一个函数中有this，<strong>这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象</strong><br />**<br /><strong>注意：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:&#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="number">12</span>,</span><br><span class="line">        <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.a); <span class="comment">//undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//window</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = o.b.fn;</span><br><span class="line">j();</span><br><span class="line"></span><br><span class="line"><span class="comment">// this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的，</span></span><br><span class="line"><span class="comment">// 虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window。</span></span><br><span class="line"><span class="comment">// 和上面直接执行的指向不一样</span></span><br></pre></td></tr></table></figure>


<h3 id="3、构造函数调用-new"><a href="#3、构造函数调用-new" class="headerlink" title="3、构造函数调用-new"></a>3、构造函数调用-new</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&quot;追梦子&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//追梦子</span></span><br><span class="line"><span class="comment">// 这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a，</span></span><br><span class="line"><span class="comment">// 因为用了new关键字就是创建一个对象实例，调用这个函数Fn的是对象a，那么this指向的自然是对象a。</span></span><br><span class="line"><span class="comment">// 那么为什么对象a中会有user，因为你已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br /><strong>如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</strong><br />还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span>:</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&#x27;追梦子&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//undefined</span></span><br><span class="line">例<span class="number">2</span>:</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&#x27;追梦子&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//undefined</span></span><br><span class="line">例<span class="number">3</span>:</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&#x27;追梦子&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//追梦子</span></span><br><span class="line">例<span class="number">4</span>:</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&#x27;追梦子&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//追梦子</span></span><br><span class="line">例<span class="number">5</span>:</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.user = <span class="string">&#x27;追梦子&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.user); <span class="comment">//追梦子</span></span><br></pre></td></tr></table></figure>
<h2 id="三、箭头函数"><a href="#三、箭头函数" class="headerlink" title="三、箭头函数"></a>三、箭头函数</h2><ul>
<li>首先箭头函数是没有this的 ，它的作用域是和父级的上下文绑定在一起的，内部的this就是定义时上层作用域中的this。即它的this就是上一层第一个包裹它的普通函数的this。</li>
<li>this定义时绑定。也就是说，箭头函数内部的this指向是固定的，this总是指向函数定义生效时所在的对象。</li>
<li>由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向，是没有效果的。</li>
<li>正是因为它没有this，所以也就不能用作构造函数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;fn&#x27;</span></span><br><span class="line">    inFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    inFn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.fn()<span class="comment">//&#x27;fn&#x27;</span></span><br><span class="line">obj1.fn.call(<span class="built_in">window</span>)<span class="comment">//&#x27;fn&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>箭头函数的this指向,是父级程序的this指向<br /></li>
<li>如果父级程序有this指向,指向向的就是父级程序的this指向<br /></li>
<li>如果父级程序没有this指向(对象,数组是没有this),指向的是window<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">  <span class="attr">a</span>:<span class="string">&#x27;myObject.a&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;window.a&#x27;</span></span><br><span class="line"></span><br><span class="line">myObject.foo()   <span class="comment">// &#x27;window.a&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="四、定时器对this的影响"><a href="#四、定时器对this的影响" class="headerlink" title="四、定时器对this的影响"></a>四、定时器对this的影响</h2>setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 this 关键字在非严格模式会指向 window (或全局)对象，严格模式下为 undefined，这和所期望的this的值是不一样的。<br />备注：在严格模式下，setTimeout( )的回调函数里面的this仍然默认指向window对象， 并不是undefined<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;Foo&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.timer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="built_in">this</span>.fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo()</span><br><span class="line"></span><br><span class="line">obj.timer()	<span class="comment">//&#x27;window&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="解决setTimeout中的this指向问题"><a href="#解决setTimeout中的this指向问题" class="headerlink" title="解决setTimeout中的this指向问题"></a>解决setTimeout中的this指向问题</h3>当在vue中使用定时器来修改一个变量值的时候，发现没有效果，这是由于setTimeout函数调用的代码运行在与所在函数完全分离的执行环境上，这会使得this指向的是window对象。<br />要想setTimeout指向正确的值，可以使用如下方法：<h4 id="1、可以使用call-apply-bind调用改变this绑定对象。"><a href="#1、可以使用call-apply-bind调用改变this绑定对象。" class="headerlink" title="1、可以使用call/apply/bind调用改变this绑定对象。"></a>1、可以使用call/apply/bind调用改变this绑定对象。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;Foo&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.timer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="built_in">this</span>.fn.call(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo()</span><br><span class="line"></span><br><span class="line">obj.timer() <span class="comment">//&#x27;Foo&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="2、使用箭头函数"><a href="#2、使用箭头函数" class="headerlink" title="2、使用箭头函数"></a>2、使用箭头函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn()<span class="comment">// 1 &#x27;obj&#x27;</span></span><br></pre></td></tr></table></figure>
此时函数的this指向的是定义它的时候的对象，也就是this指向了data内中对应的变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">left</span>: -<span class="number">9999</span>,</span><br><span class="line">      <span class="attr">bottom</span>: -<span class="number">9999</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">cancelMask</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bottom = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.left = <span class="number">0</span>;</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3、将当前对象的this保存为一个变量"><a href="#3、将当前对象的this保存为一个变量" class="headerlink" title="3、将当前对象的this保存为一个变量"></a>3、将当前对象的this保存为一个变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">left</span>: -<span class="number">9999</span>,</span><br><span class="line">      <span class="attr">bottom</span>: -<span class="number">9999</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">cancelMask</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        that.bottom = <span class="number">0</span>;</span><br><span class="line">        that.left = <span class="number">0</span>;</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">----</span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="built_in">this</span></span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;Foo&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(that.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.timer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="built_in">this</span>.fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo()</span><br><span class="line"></span><br><span class="line">obj.timer()	<span class="comment">//&#x27;Foo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>方法中将this存在一个对象中，此时执行setTimeout函数时，setTimeout函数内的that就会访问到这个变量，就会得到当前对象。</p>
<div class="qr-code"></div><img class="qrcode-img" src="/img/weixin.jpeg"><div class="qrcode-desc"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/09/30/%E8%A7%86%E5%9B%BE%E5%93%8D%E5%BA%94--%E4%BE%A6%E5%90%AC%E5%99%A8watch/"><i class="fa fa-chevron-left"></i><span>视图响应-watch对象、数组</span></a></div><div class="next-post pull-right"><a href="/2019/06/16/websocket/"><span>websocket js/node</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '618b746d5ea5d3e669cf',
  clientSecret: 'ebde2105d18532a7431b987c41e9904e905b5bfd',
  repo: 'lilucode.github.io',
  owner: 'lilucode',
  admin: 'lilucode',
  id: md5(window.location.pathname)
})
gitalk.render('gitalk-container')</script></article></section></article><footer id="footer-outer"><div id="footer-inner"><p class="footer-text">Copyright &copy; 2018 LI-LU</p></div></footer></body><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/main.js" defer></script></html>